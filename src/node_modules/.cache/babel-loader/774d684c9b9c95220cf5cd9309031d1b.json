{"ast":null,"code":"/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\nvar JpegImage = function jpegImage() {\n  \"use strict\";\n\n  var dctZigZag = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);\n  var dctCos1 = 4017; // cos(pi/16)\n\n  var dctSin1 = 799; // sin(pi/16)\n\n  var dctCos3 = 3406; // cos(3*pi/16)\n\n  var dctSin3 = 2276; // sin(3*pi/16)\n\n  var dctCos6 = 1567; // cos(6*pi/16)\n\n  var dctSin6 = 3784; // sin(6*pi/16)\n\n  var dctSqrt2 = 5793; // sqrt(2)\n\n  var dctSqrt1d2 = 2896; // sqrt(2) / 2\n\n  function constructor() {}\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0,\n        code = [],\n        i,\n        j,\n        length = 16;\n\n    while (length > 0 && !codeLengths[length - 1]) length--;\n\n    code.push({\n      children: [],\n      index: 0\n    });\n    var p = code[0],\n        q;\n\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n\n        while (p.index > 0) {\n          if (code.length === 0) throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n\n        p.index++;\n        code.push(p);\n\n        while (code.length <= i) {\n          code.push(q = {\n            children: [],\n            index: 0\n          });\n          p.children[p.index] = q.children;\n          p = q;\n        }\n\n        k++;\n      }\n\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {\n          children: [],\n          index: 0\n        });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH,\n        maxV = frame.maxV;\n    var startOffset = offset,\n        bitsData = 0,\n        bitsCount = 0;\n\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return bitsData >> bitsCount & 1;\n      }\n\n      bitsData = data[offset++];\n\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + (bitsData << 8 | nextByte).toString(16));\n        } // unstuff 0\n\n      }\n\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n\n    function decodeHuffman(tree) {\n      var node = tree,\n          bit;\n\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number') return node;\n        if (typeof node !== 'object') throw new Error(\"invalid huffman sequence\");\n      }\n\n      return null;\n    }\n\n    function receive(length) {\n      var n = 0;\n\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = n << 1 | bit;\n        length--;\n      }\n\n      return n;\n    }\n\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << length - 1) return n;\n      return n + (-1 << length) + 1;\n    }\n\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0] = component.pred += diff;\n      var k = 1;\n\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15,\n            r = rs >> 4;\n\n        if (s === 0) {\n          if (r < 15) break;\n          k += 16;\n          continue;\n        }\n\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n      zz[0] = component.pred += diff;\n    }\n\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n\n    var eobrun = 0;\n\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n\n      var k = spectralStart,\n          e = spectralEnd;\n\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15,\n            r = rs >> 4;\n\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n\n          k += 16;\n          continue;\n        }\n\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n\n    var successiveACState = 0,\n        successiveACNextValue;\n\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart,\n          e = spectralEnd,\n          r = 0;\n\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n\n        switch (successiveACState) {\n          case 0:\n            // initial state\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15,\n                r = rs >> 4;\n\n            if (s === 0) {\n              if (r < 15) {\n                eobrun = receive(r) + (1 << r);\n                successiveACState = 4;\n              } else {\n                r = 16;\n                successiveACState = 1;\n              }\n            } else {\n              if (s !== 1) throw new Error(\"invalid ACn encoding\");\n              successiveACNextValue = receiveAndExtend(s);\n              successiveACState = r ? 2 : 3;\n            }\n\n            continue;\n\n          case 1: // skipping r zero items\n\n          case 2:\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;else {\n              r--;\n              if (r === 0) successiveACState = successiveACState == 2 ? 3 : 0;\n            }\n            break;\n\n          case 3:\n            // set value for a zero item\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;else {\n              zz[z] = successiveACNextValue << successive;\n              successiveACState = 0;\n            }\n            break;\n\n          case 4:\n            // eob\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;\n            break;\n        }\n\n        k++;\n      }\n\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0) successiveACState = 0;\n      }\n    }\n\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = mcu / mcusPerLine | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col; // If the block is missing and we're in tolerant mode, just skip it.\n\n      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding) return;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = mcu / component.blocksPerLine | 0;\n      var blockCol = mcu % component.blocksPerLine; // If the block is missing and we're in tolerant mode, just skip it.\n\n      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding) return;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n\n    if (progressive) {\n      if (spectralStart === 0) decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;else decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0,\n        marker;\n    var mcuExpected;\n\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n\n    if (!resetInterval) resetInterval = mcuExpected;\n    var h, v;\n\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++) components[i].pred = 0;\n\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n\n          mcu++; // If we've reached our expected MCU's, stop decoding\n\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      if (mcu === mcuExpected) {\n        // Skip trailing bytes at the end of the scan - until we reach the next marker\n        do {\n          if (data[offset] === 0xFF) {\n            if (data[offset + 1] !== 0x00) {\n              break;\n            }\n          }\n\n          offset += 1;\n        } while (offset < data.length - 2);\n      } // find marker\n\n\n      bitsCount = 0;\n      marker = data[offset] << 8 | data[offset + 1];\n\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) {\n        // RSTx\n        offset += 2;\n      } else break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3; // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.\n\n    var R = new Int32Array(64),\n        r = new Uint8Array(64); // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i; // dequant\n\n      for (i = 0; i < 64; i++) p[i] = zz[i] * qt[i]; // inverse DCT on rows\n\n\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i; // check for all-zero AC coefficients\n\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {\n          t = dctSqrt2 * p[0 + row] + 512 >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        } // stage 4\n\n\n        v0 = dctSqrt2 * p[0 + row] + 128 >> 8;\n        v1 = dctSqrt2 * p[4 + row] + 128 >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;\n        v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4; // stage 3\n\n        t = v0 - v1 + 1 >> 1;\n        v0 = v0 + v1 + 1 >> 1;\n        v1 = t;\n        t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\n        v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\n        v3 = t;\n        t = v4 - v6 + 1 >> 1;\n        v4 = v4 + v6 + 1 >> 1;\n        v6 = t;\n        t = v7 + v5 + 1 >> 1;\n        v5 = v7 - v5 + 1 >> 1;\n        v7 = t; // stage 2\n\n        t = v0 - v3 + 1 >> 1;\n        v0 = v0 + v3 + 1 >> 1;\n        v3 = t;\n        t = v1 - v2 + 1 >> 1;\n        v1 = v1 + v2 + 1 >> 1;\n        v2 = t;\n        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n        v7 = t;\n        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n        v6 = t; // stage 1\n\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      } // inverse DCT on columns\n\n\n      for (i = 0; i < 8; ++i) {\n        var col = i; // check for all-zero AC coefficients\n\n        if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {\n          t = dctSqrt2 * dataIn[i + 0] + 8192 >> 14;\n          p[0 * 8 + col] = t;\n          p[1 * 8 + col] = t;\n          p[2 * 8 + col] = t;\n          p[3 * 8 + col] = t;\n          p[4 * 8 + col] = t;\n          p[5 * 8 + col] = t;\n          p[6 * 8 + col] = t;\n          p[7 * 8 + col] = t;\n          continue;\n        } // stage 4\n\n\n        v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;\n        v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;\n        v2 = p[2 * 8 + col];\n        v3 = p[6 * 8 + col];\n        v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;\n        v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;\n        v5 = p[3 * 8 + col];\n        v6 = p[5 * 8 + col]; // stage 3\n\n        t = v0 - v1 + 1 >> 1;\n        v0 = v0 + v1 + 1 >> 1;\n        v1 = t;\n        t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\n        v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\n        v3 = t;\n        t = v4 - v6 + 1 >> 1;\n        v4 = v4 + v6 + 1 >> 1;\n        v6 = t;\n        t = v7 + v5 + 1 >> 1;\n        v5 = v7 - v5 + 1 >> 1;\n        v7 = t; // stage 2\n\n        t = v0 - v3 + 1 >> 1;\n        v0 = v0 + v3 + 1 >> 1;\n        v3 = t;\n        t = v1 - v2 + 1 >> 1;\n        v1 = v1 + v2 + 1 >> 1;\n        v2 = t;\n        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n        v7 = t;\n        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n        v6 = t; // stage 1\n\n        p[0 * 8 + col] = v0 + v7;\n        p[7 * 8 + col] = v0 - v7;\n        p[1 * 8 + col] = v1 + v6;\n        p[6 * 8 + col] = v1 - v6;\n        p[2 * 8 + col] = v2 + v5;\n        p[5 * 8 + col] = v2 - v5;\n        p[3 * 8 + col] = v3 + v4;\n        p[4 * 8 + col] = v3 - v4;\n      } // convert to 8-bit integers\n\n\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + (p[i] + 8 >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);\n    var i, j;\n\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n\n      for (i = 0; i < 8; i++) lines.push(new Uint8Array(samplesPerLine));\n\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n        var offset = 0,\n            sample = blockCol << 3;\n\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n\n          for (i = 0; i < 8; i++) line[sample + i] = r[offset++];\n        }\n      }\n    }\n\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n\n      xhr.onload = function () {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload) this.onload();\n      }.bind(this);\n\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;\n      var offset = 0,\n          length = data.length;\n\n      function readUint16() {\n        var value = data[offset] << 8 | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n\n      function prepareComponents(frame) {\n        var maxH = 0,\n            maxV = 0;\n        var component, componentId;\n\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;\n            var blocks = []; // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)\n\n            requestMemoryAllocation(blocksToAllocate * 256);\n\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n\n              for (var j = 0; j < blocksPerLineForMcu; j++) row.push(new Int32Array(64));\n\n              blocks.push(row);\n            }\n\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [],\n          frames = [];\n      var huffmanTablesAC = [],\n          huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      var malformedDataOffset = -1;\n      this.comments = [];\n\n      if (fileMarker != 0xFFD8) {\n        // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n\n      while (fileMarker != 0xFFD9) {\n        // EOI (End of image)\n        var i, j, l;\n\n        switch (fileMarker) {\n          case 0xFF00:\n            break;\n\n          case 0xFFE0: // APP0 (Application Specific)\n\n          case 0xFFE1: // APP1\n\n          case 0xFFE2: // APP2\n\n          case 0xFFE3: // APP3\n\n          case 0xFFE4: // APP4\n\n          case 0xFFE5: // APP5\n\n          case 0xFFE6: // APP6\n\n          case 0xFFE7: // APP7\n\n          case 0xFFE8: // APP8\n\n          case 0xFFE9: // APP9\n\n          case 0xFFEA: // APP10\n\n          case 0xFFEB: // APP11\n\n          case 0xFFEC: // APP12\n\n          case 0xFFED: // APP13\n\n          case 0xFFEE: // APP14\n\n          case 0xFFEF: // APP15\n\n          case 0xFFFE:\n            // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFFE) {\n              var comment = String.fromCharCode.apply(null, appData);\n              this.comments.push(comment);\n            }\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {\n                // 'JFIF\\x00'\n                jfif = {\n                  version: {\n                    major: appData[5],\n                    minor: appData[6]\n                  },\n                  densityUnits: appData[7],\n                  xDensity: appData[8] << 8 | appData[9],\n                  yDensity: appData[10] << 8 | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            } // TODO APP1 - Exif\n\n\n            if (fileMarker === 0xFFE1) {\n              if (appData[0] === 0x45 && appData[1] === 0x78 && appData[2] === 0x69 && appData[3] === 0x66 && appData[4] === 0) {\n                // 'EXIF\\x00'\n                this.exifBuffer = appData.subarray(5, appData.length);\n              }\n            }\n\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) {\n                // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: appData[7] << 8 | appData[8],\n                  flags1: appData[9] << 8 | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n\n            break;\n\n          case 0xFFDB:\n            // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              requestMemoryAllocation(64 * 4);\n              var tableData = new Int32Array(64);\n\n              if (quantizationTableSpec >> 4 === 0) {\n                // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if (quantizationTableSpec >> 4 === 1) {\n                //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else throw new Error(\"DQT: invalid table spec\");\n\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n\n          case 0xFFC2:\n            // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n\n            frame = {};\n            frame.extended = fileMarker === 0xFFC1;\n            frame.progressive = fileMarker === 0xFFC2;\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;\n\n            if (pixelsInFrame > maxResolutionInPixels) {\n              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);\n              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);\n            }\n\n            var componentsCount = data[offset++],\n                componentId;\n            var maxH = 0,\n                maxV = 0;\n\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4:\n            // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n\n              for (j = 0; j < 16; j++, offset++) {\n                codeLengthSum += codeLengths[j] = data[offset];\n              }\n\n              requestMemoryAllocation(16 + codeLengthSum);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n\n              for (j = 0; j < codeLengthSum; j++, offset++) huffmanValues[j] = data[offset];\n\n              i += 17 + codeLengthSum;\n              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n            }\n\n            break;\n\n          case 0xFFDD:\n            // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDC:\n            // Number of Lines marker\n            readUint16(); // skip data length\n\n            readUint16(); // Ignore this data since it represents the image height\n\n            break;\n\n          case 0xFFDA:\n            // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [],\n                component;\n\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);\n            offset += processed;\n            break;\n\n          case 0xFFFF:\n            // Fill bytes\n            if (data[offset] !== 0xFF) {\n              // Avoid skipping a valid marker.\n              offset--;\n            }\n\n            break;\n\n          default:\n            if (data[offset - 3] == 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            } else if (fileMarker === 0xE0 || fileMarker == 0xE1) {\n              // Recover from malformed APP1 markers popular in some phone models.\n              // See https://github.com/eugeneware/jpeg-js/issues/82\n              if (malformedDataOffset !== -1) {\n                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);\n              }\n\n              malformedDataOffset = offset - 1;\n              const nextOffset = readUint16();\n\n              if (data[offset + nextOffset - 2] === 0xFF) {\n                offset += nextOffset - 2;\n                break;\n              }\n            }\n\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n\n        fileMarker = readUint16();\n      }\n\n      if (frames.length != 1) throw new Error(\"only single frame JPEGs supported\"); // set each frame's components quantization table\n\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width,\n          scaleY = this.height / height;\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      requestMemoryAllocation(dataLength);\n      var data = new Uint8Array(dataLength);\n\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | x * component1.scaleX * scaleX];\n              data[offset++] = Y;\n            }\n          }\n\n          break;\n\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | x * component1.scaleX * scaleX];\n              data[offset++] = Y;\n              Y = component2Line[0 | x * component2.scaleX * scaleX];\n              data[offset++] = Y;\n            }\n          }\n\n          break;\n\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true; // The adobe transform marker overrides any previous setting\n\n          if (this.adobe && this.adobe.transformCode) colorTransform = true;else if (typeof this.opts.colorTransform !== 'undefined') colorTransform = !!this.opts.colorTransform;\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            component3Line = component3.lines[0 | y * component3.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | x * component1.scaleX * scaleX];\n                G = component2Line[0 | x * component2.scaleX * scaleX];\n                B = component3Line[0 | x * component3.scaleX * scaleX];\n              } else {\n                Y = component1Line[0 | x * component1.scaleX * scaleX];\n                Cb = component2Line[0 | x * component2.scaleX * scaleX];\n                Cr = component3Line[0 | x * component3.scaleX * scaleX];\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n\n          break;\n\n        case 4:\n          if (!this.adobe) throw new Error('Unsupported color mode (4 components)'); // The default transform for four components is false\n\n          colorTransform = false; // The adobe transform marker overrides any previous setting\n\n          if (this.adobe && this.adobe.transformCode) colorTransform = true;else if (typeof this.opts.colorTransform !== 'undefined') colorTransform = !!this.opts.colorTransform;\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            component3Line = component3.lines[0 | y * component3.scaleY * scaleY];\n            component4Line = component4.lines[0 | y * component4.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | x * component1.scaleX * scaleX];\n                M = component2Line[0 | x * component2.scaleX * scaleX];\n                Ye = component3Line[0 | x * component3.scaleX * scaleX];\n                K = component4Line[0 | x * component4.scaleX * scaleX];\n              } else {\n                Y = component1Line[0 | x * component1.scaleX * scaleX];\n                Cb = component2Line[0 | x * component2.scaleX * scaleX];\n                Cr = component3Line[0 | x * component3.scaleX * scaleX];\n                K = component4Line[0 | x * component4.scaleX * scaleX];\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = 255 - C;\n              data[offset++] = 255 - M;\n              data[offset++] = 255 - Ye;\n              data[offset++] = 255 - K;\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported color mode');\n      }\n\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width,\n          height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0,\n          j = 0,\n          x,\n          y;\n      var Y, K, C, M, R, G, B;\n\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n\n          break;\n\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n\n          break;\n\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  }; // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.\n\n  var totalBytesAllocated = 0;\n  var maxMemoryUsageBytes = 0;\n\n  function requestMemoryAllocation(increaseAmount = 0) {\n    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;\n\n    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {\n      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);\n      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);\n    }\n\n    totalBytesAllocated = totalMemoryImpactBytes;\n  }\n\n  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {\n    totalBytesAllocated = 0;\n    maxMemoryUsageBytes = maxMemoryUsageBytes_;\n  };\n\n  constructor.getBytesAllocated = function () {\n    return totalBytesAllocated;\n  };\n\n  constructor.requestMemoryAllocation = requestMemoryAllocation;\n  return constructor;\n}();\n\nif (typeof module !== 'undefined') {\n  module.exports = decode;\n} else if (typeof window !== 'undefined') {\n  window['jpeg-js'] = window['jpeg-js'] || {};\n  window['jpeg-js'].decode = decode;\n}\n\nfunction decode(jpegData, userOpts = {}) {\n  var defaultOpts = {\n    // \"undefined\" means \"Choose whether to transform colors based on the imageâ€™s color model.\"\n    colorTransform: undefined,\n    useTArray: false,\n    formatAsRGBA: true,\n    tolerantDecoding: true,\n    maxResolutionInMP: 100,\n    // Don't decode more than 100 megapixels\n    maxMemoryUsageInMB: 512 // Don't decode if memory footprint is more than 512MB\n\n  };\n  var opts = { ...defaultOpts,\n    ...userOpts\n  };\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.opts = opts; // If this constructor ever supports async decoding this will need to be done differently.\n  // Until then, treating as singleton limit is fine.\n\n  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);\n  decoder.parse(arr);\n  var channels = opts.formatAsRGBA ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n\n  try {\n    JpegImage.requestMemoryAllocation(bytesNeeded);\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      exifBuffer: decoder.exifBuffer,\n      data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)\n    };\n\n    if (decoder.comments.length > 0) {\n      image[\"comments\"] = decoder.comments;\n    }\n  } catch (err) {\n    if (err instanceof RangeError) {\n      throw new Error(\"Could not allocate enough memory for the image. \" + \"Required: \" + bytesNeeded);\n    } else {\n      throw err;\n    }\n  }\n\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n  return image;\n}","map":{"version":3,"sources":["/home/alexemdesgagne/octopus-telemetry/src/node_modules/jpeg-js/lib/decoder.js"],"names":["JpegImage","jpegImage","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","constructor","buildHuffmanTable","codeLengths","values","k","code","i","j","length","push","children","index","p","q","pop","Error","decodeScan","data","offset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","opts","precision","samplesPerLine","scanLines","mcusPerLine","progressive","maxH","maxV","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","node","bit","receive","n","receiveAndExtend","decodeBaseline","component","zz","t","huffmanTableDC","diff","pred","rs","huffmanTableAC","s","r","z","decodeDCFirst","decodeDCSuccessive","eobrun","decodeACFirst","e","successiveACState","successiveACNextValue","decodeACSuccessive","direction","decodeMcu","decode","mcu","row","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","undefined","tolerantDecoding","decodeBlock","blocksPerLine","componentsLength","decodeFn","marker","mcuExpected","blocksPerColumn","mcusPerColumn","buildComponentData","lines","R","Uint8Array","quantizeAndInverse","dataOut","dataIn","qt","quantizationTable","v0","v1","v2","v3","v4","v5","v6","v7","sample","requestMemoryAllocation","scanLine","line","clampTo8bit","a","prototype","load","path","xhr","XMLHttpRequest","open","responseType","onload","response","mozResponseArrayBuffer","parse","bind","send","maxResolutionInPixels","maxResolutionInMP","readUint16","value","readDataBlock","array","subarray","prepareComponents","componentId","hasOwnProperty","Math","ceil","blocksPerLineForMcu","blocksPerColumnForMcu","blocksToAllocate","jfif","adobe","pixels","quantizationTables","frames","huffmanTablesAC","huffmanTablesDC","fileMarker","malformedDataOffset","comments","l","appData","comment","String","fromCharCode","apply","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","exifBuffer","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","componentsOrder","pixelsInFrame","exceededAmount","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","scanLength","selectorsCount","tableSpec","successiveApproximation","processed","nextOffset","cp","width","height","scaleX","scaleY","getData","component1","component2","component3","component4","component1Line","component2Line","component3Line","component4Line","x","y","Y","Cb","Cr","K","C","M","Ye","G","B","colorTransform","dataLength","copyToImageData","imageData","formatAsRGBA","imageDataArray","totalBytesAllocated","maxMemoryUsageBytes","increaseAmount","totalMemoryImpactBytes","resetMaxMemoryUsage","maxMemoryUsageBytes_","getBytesAllocated","module","exports","window","jpegData","userOpts","defaultOpts","useTArray","maxMemoryUsageInMB","arr","decoder","channels","bytesNeeded","image","Buffer","alloc","err","RangeError"],"mappings":"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","sourcesContent":["/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = (function jpegImage() {\n  \"use strict\";\n  var dctZigZag = new Int32Array([\n     0,\n     1,  8,\n    16,  9,  2,\n     3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n     5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13,  6,\n     7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63\n  ]);\n\n  var dctCos1  =  4017   // cos(pi/16)\n  var dctSin1  =   799   // sin(pi/16)\n  var dctCos3  =  3406   // cos(3*pi/16)\n  var dctSin3  =  2276   // sin(3*pi/16)\n  var dctCos6  =  1567   // cos(6*pi/16)\n  var dctSin6  =  3784   // sin(6*pi/16)\n  var dctSqrt2 =  5793   // sqrt(2)\n  var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n  function constructor() {\n  }\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n      length--;\n    code.push({children: [], index: 0});\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          if (code.length === 0)\n            throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {children: [], index: 0});\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {children: [], index: 0});\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset,\n                      frame, components, resetInterval,\n                      spectralStart, spectralEnd,\n                      successivePrev, successive, opts) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return (bitsData >> bitsCount) & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16));\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree, bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number')\n          return node;\n        if (typeof node !== 'object')\n          throw new Error(\"invalid huffman sequence\");\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = (n << 1) | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << (length - 1))\n        return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0]= (component.pred += diff);\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15)\n            break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n      zz[0] = (component.pred += diff);\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart, e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart, e = spectralEnd, r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n        switch (successiveACState) {\n        case 0: // initial state\n          var rs = decodeHuffman(component.huffmanTableAC);\n          var s = rs & 15, r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1)\n              throw new Error(\"invalid ACn encoding\");\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            r--;\n            if (r === 0)\n              successiveACState = successiveACState == 2 ? 3 : 0;\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0)\n          successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = (mcu / mcusPerLine) | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      // If the block is missing and we're in tolerant mode, just skip it.\n      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)\n        return;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = (mcu / component.blocksPerLine) | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      // If the block is missing and we're in tolerant mode, just skip it.\n      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)\n        return;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0)\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n      else\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++)\n        components[i].pred = 0;\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      if (mcu === mcuExpected) {\n        // Skip trailing bytes at the end of the scan - until we reach the next marker\n        do {\n          if (data[offset] === 0xFF) {\n            if (data[offset + 1] !== 0x00) {\n              break;\n            }\n          }\n          offset += 1;\n        } while (offset < data.length - 2);\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = (data[offset] << 8) | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n        offset += 2;\n      }\n      else\n        break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.\n    var R = new Int32Array(64), r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++)\n        p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n            p[7 + row] == 0) {\n          t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = (v0 - v1+ 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n            p[7*8 + col] == 0) {\n          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;\n          p[0*8 + col] = t;\n          p[1*8 + col] = t;\n          p[2*8 + col] = t;\n          p[3*8 + col] = t;\n          p[4*8 + col] = t;\n          p[5*8 + col] = t;\n          p[6*8 + col] = t;\n          p[7*8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n        v2 = p[2*8 + col];\n        v3 = p[6*8 + col];\n        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n        v5 = p[3*8 + col];\n        v6 = p[5*8 + col];\n\n        // stage 3\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0*8 + col] = v0 + v7;\n        p[7*8 + col] = v0 - v7;\n        p[1*8 + col] = v1 + v6;\n        p[6*8 + col] = v1 - v6;\n        p[2*8 + col] = v2 + v5;\n        p[5*8 + col] = v2 - v5;\n        p[3*8 + col] = v3 + v4;\n        p[4*8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + ((p[i] + 8) >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);\n\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++)\n        lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n        var offset = 0, sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++)\n            line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;\n      var offset = 0, length = data.length;\n      function readUint16() {\n        var value = (data[offset] << 8) | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0, maxV = 0;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;\n            var blocks = [];\n\n            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)\n            requestMemoryAllocation(blocksToAllocate * 256);\n\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++)\n                row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [], frames = [];\n      var huffmanTablesAC = [], huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      var malformedDataOffset = -1;\n      this.comments = [];\n      if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) { // EOI (End of image)\n        var i, j, l;\n        switch(fileMarker) {\n          case 0xFF00: break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE: // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFFE) {\n              var comment = String.fromCharCode.apply(null, appData);\n              this.comments.push(comment);\n            }\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                jfif = {\n                  version: { major: appData[5], minor: appData[6] },\n                  densityUnits: appData[7],\n                  xDensity: (appData[8] << 8) | appData[9],\n                  yDensity: (appData[10] << 8) | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFE1) {\n              if (appData[0] === 0x45 &&\n                appData[1] === 0x78 &&\n                appData[2] === 0x69 &&\n                appData[3] === 0x66 &&\n                appData[4] === 0) { // 'EXIF\\x00'\n                this.exifBuffer = appData.subarray(5, appData.length);\n              }\n            }\n\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: (appData[7] << 8) | appData[8],\n                  flags1: (appData[9] << 8) | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n\n          case 0xFFDB: // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              requestMemoryAllocation(64 * 4);\n              var tableData = new Int32Array(64);\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else\n                throw new Error(\"DQT: invalid table spec\");\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = (fileMarker === 0xFFC1);\n            frame.progressive = (fileMarker === 0xFFC2);\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n\n            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;\n            if (pixelsInFrame > maxResolutionInPixels) {\n              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);\n              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);\n            }\n\n            var componentsCount = data[offset++], componentId;\n            var maxH = 0, maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4: // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++) {\n                codeLengthSum += (codeLengths[j] = data[offset]);\n              }\n              requestMemoryAllocation(16 + codeLengthSum);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++)\n                huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n\n              ((huffmanTableSpec >> 4) === 0 ?\n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n\n          case 0xFFDD: // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDC: // Number of Lines marker\n            readUint16() // skip data length\n            readUint16() // Ignore this data since it represents the image height\n            break;\n            \n          case 0xFFDA: // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [], component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset,\n              frame, components, resetInterval,\n              spectralStart, spectralEnd,\n              successiveApproximation >> 4, successiveApproximation & 15, this.opts);\n            offset += processed;\n            break;\n\n          case 0xFFFF: // Fill bytes\n            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n          default:\n            if (data[offset - 3] == 0xFF &&\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            else if (fileMarker === 0xE0 || fileMarker == 0xE1) {\n              // Recover from malformed APP1 markers popular in some phone models.\n              // See https://github.com/eugeneware/jpeg-js/issues/82\n              if (malformedDataOffset !== -1) {\n                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);\n              }\n              malformedDataOffset = offset - 1;\n              const nextOffset = readUint16();\n              if (data[offset + nextOffset - 2] === 0xFF) {\n                offset += nextOffset - 2;\n                break;\n              }\n            }\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1)\n        throw new Error(\"only single frame JPEGs supported\");\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width, scaleY = this.height / height;\n\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      requestMemoryAllocation(dataLength);\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n              data[offset++] = Y;\n              Y = component2Line[0 | (x * component2.scaleX * scaleX)];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.opts.colorTransform !== 'undefined')\n            colorTransform = !!this.opts.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | (x * component1.scaleX * scaleX)];\n                G = component2Line[0 | (x * component2.scaleX * scaleX)];\n                B = component3Line[0 | (x * component3.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe)\n            throw new Error('Unsupported color mode (4 components)');\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.opts.colorTransform !== 'undefined')\n            colorTransform = !!this.opts.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | (x * component1.scaleX * scaleX)];\n                M = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255-C;\n              data[offset++] = 255-M;\n              data[offset++] = 255-Ye;\n              data[offset++] = 255-K;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width, height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0, j = 0, x, y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n\n\n  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.\n  var totalBytesAllocated = 0;\n  var maxMemoryUsageBytes = 0;\n  function requestMemoryAllocation(increaseAmount = 0) {\n    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;\n    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {\n      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);\n      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);\n    }\n\n    totalBytesAllocated = totalMemoryImpactBytes;\n  }\n\n  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {\n    totalBytesAllocated = 0;\n    maxMemoryUsageBytes = maxMemoryUsageBytes_;\n  };\n\n  constructor.getBytesAllocated = function () {\n    return totalBytesAllocated;\n  };\n\n  constructor.requestMemoryAllocation = requestMemoryAllocation;\n\n  return constructor;\n})();\n\nif (typeof module !== 'undefined') {\n\tmodule.exports = decode;\n} else if (typeof window !== 'undefined') {\n\twindow['jpeg-js'] = window['jpeg-js'] || {};\n\twindow['jpeg-js'].decode = decode;\n}\n\nfunction decode(jpegData, userOpts = {}) {\n  var defaultOpts = {\n    // \"undefined\" means \"Choose whether to transform colors based on the imageâ€™s color model.\"\n    colorTransform: undefined,\n    useTArray: false,\n    formatAsRGBA: true,\n    tolerantDecoding: true,\n    maxResolutionInMP: 100, // Don't decode more than 100 megapixels\n    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB\n  };\n\n  var opts = {...defaultOpts, ...userOpts};\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.opts = opts;\n  // If this constructor ever supports async decoding this will need to be done differently.\n  // Until then, treating as singleton limit is fine.\n  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);\n  decoder.parse(arr);\n\n  var channels = (opts.formatAsRGBA) ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n  try {\n    JpegImage.requestMemoryAllocation(bytesNeeded);\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      exifBuffer: decoder.exifBuffer,\n      data: opts.useTArray ?\n        new Uint8Array(bytesNeeded) :\n        Buffer.alloc(bytesNeeded)\n    };\n    if(decoder.comments.length > 0) {\n      image[\"comments\"] = decoder.comments;\n    }\n  } catch (err){\n    if (err instanceof RangeError){\n      throw new Error(\"Could not allocate enough memory for the image. \" +\n                      \"Required: \" + bytesNeeded);\n    } else {\n      throw err;\n    }\n  }\n\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n\n  return image;\n}\n"]},"metadata":{},"sourceType":"script"}